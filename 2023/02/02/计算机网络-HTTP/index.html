<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="QingZhou,1203715903@qq.com"><title>计算机网络-HTTP · 轻舟</title><meta name="description" content="计算机网络-HTTP基础概念HTTP (HyperText Transfer Protocol) 超文本传输协议， 是一个在计算机世界里专门在「两点」之间传输文字、图片、音频、视频等「超文本」数据的「约定和规范」。
HTTP状态码

1xx 类状态码属于提示信息，是协议处理中的一种中间状态。

2x"><meta name="keywords" content="Hexo,HTML,CSS,Java,Note"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">轻舟</a></h3><div class="description"><p>走下去，太阳自然会升起.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/https://github.com/xiaduxiu/xiaduxiu.github.io"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>计算机网络-HTTP</a></h3></div><div class="post-content"><h1 id="计算机网络-HTTP"><a href="#计算机网络-HTTP" class="headerlink" title="计算机网络-HTTP"></a>计算机网络-HTTP</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>HTTP (HyperText Transfer Protocol) 超文本传输协议， 是一个<strong>在计算机世界里专门在「两点」之间传输文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<p><strong>HTTP状态码</strong></p>
<ul>
<li><p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态。</p>
</li>
<li><p>2xx 类状态码表示服务器成功处理客户端请求</p>
<ul>
<li>200 OK  成功状态码</li>
<li>204 No Content ，与200基本相同，响应头没有body数据</li>
<li>206 Partial Content, HTTP分块或断点续传，表示响应返回body数据只是一部分</li>
</ul>
</li>
<li><p>3xx 类状态码表示客户端请求资源发生变动，需要客户端用新的URL重新发送请求，也就是重定向</p>
<ul>
<li><p>301 Moved Permanently 永久重定向，请求资源已经不存在，改用新的URL再次访问</p>
</li>
<li><p>302 Found , 临时重定向，请求资源还在，暂时需要用另一个URL访问</p>
<p>301 和 302 都在响应头使用字段 Location, 指明后续要跳转的URL，浏览器会自动重定向新的URL</p>
</li>
<li><p>304 Not Modified , 不具备跳转，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
</li>
<li><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理</p>
<ul>
<li>400 Bad Request , 客户端请求报文有错误</li>
<li>403 Forbidden , 服务器禁止访问资源，并不是客户端请求出错</li>
<li>404 Not Found， 请求资源在服务器上不存在或未找到</li>
</ul>
</li>
<li><p>5xx 类状态码表示客户端报文正确，但是服务器内部处理错误</p>
<ul>
<li>500 Internal Server Error, 服务器出错，笼统错误，不知道具体错误</li>
<li>501 Not Implemented 客户端请求功能还不支持</li>
<li>502 Bad Gateway 服务器作为网关或代理时返回的错误，表示服务器自身工作正常，访问后端服务器发生错误</li>
<li>503 Service Unavaiilable 服务器忙，暂时无法响应客户端</li>
</ul>
</li>
</ul>
<p><strong>HTTP常见字段</strong></p>
<ul>
<li><p>Host:<a target="_blank" rel="noopener" href="http://www.a.com/">www.A.com</a>  客户端发送请求时，指定服务器域名</p>
</li>
<li><p>Content-Length:1000 标识响应的数据长度。<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></p>
</li>
<li><p>Connection:Keep-Alive  用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。<strong>连接不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</strong></p>
</li>
<li><p>Content-Type: text/html; Charset=utf-8     服务器响应客户端的数据格式  json/application;Charsret=utf-8</p>
</li>
<li><p>Accept:<em>/</em> 声明接收数据格式</p>
</li>
<li><p>Accept-Encoding:gzip  说明字段压缩的方法，数据使用了什么压缩格式</p>
</li>
</ul>
<h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><p>GET的语义是从服务器获取资源，这个资源可以是 文本、网页、流媒体文件等。GET的请求参数写在URL上，浏览器对URL有长度限制。</p>
<p>POST的语义的根据请求报文对指定资源做出处理，具体方法根据资源类型而不同。POST请求数据都写在报文body中，可以是任意格式，任意大小。</p>
<p><strong>GET和POST都是安全和幂等的吗？</strong></p>
<p>安全： 请求方法不会破坏服务器上的资源。</p>
<p>幂等：多次执行相同的操作，结果都是相同的。</p>
<p><strong>GET方法是安全和幂等的，因为只读操作，不会更改服务器资源，且每次结果都是相同的。所以可以对 GET 请求的数据做缓存</strong>，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</p>
<p><strong>POST是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的</strong>。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</p>
<p>任何请求都可以带 body 的，只是因为 RFC 规范定义的 GET 请求是获取资源，所以不需要用到 body。URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>如果每次请求得到的数据都一样的，可以把这对「请求-响应」的数据<strong>缓存在本地</strong>，下次直接读取本地的数据，不必再请求服务器，这样的话 HTTP/1.1 的性能肯定提升。</p>
<p>HTTP缓存有两种实现方式： <strong>强制缓存和协商缓存</strong>。</p>
<p><strong>强制缓存</strong></p>
<p>是否使用缓存的选择权在客户端手里，只要客户端判断缓存没有过期，那就用本地缓存。</p>
<p>强制缓存利用HTTP响应头部字段实现，有两个字段，它们标识资源在客户端缓存的有效期：</p>
<ul>
<li>Cache-Control, 是一个相对时间，优先级高</li>
<li>Expires, 是一个绝对时间</li>
</ul>
<p>Cache-Control的实现流程：</p>
<ul>
<li>客户端第一次请求服务器资源时，服务器在返回资源的同时，在Response头部加上Cache-Control 设置过期时间大小</li>
<li>客户端再次访问服务器该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<p><strong>协商缓存</strong></p>
<p>请求的响应码是 <code>304</code>，告诉客户端可以使用本地缓存的资源，<strong>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存</strong>。</p>
<p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p>ETag的优先级高一些，因为：</p>
<ol>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ol>
<p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<p><strong>HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</strong></p>
<p><strong>HTTP 有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</strong></p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。<code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p>
<h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><ul>
<li>HTTP 信息明文传输，存在安全风险的问题。HTTPS 则在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立 TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<p>非对称加密：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>
<p>非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<p><strong>问题1：</strong> <strong>HTTPS一定安全可靠吗？</strong></p>
<p>​        客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」        完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<p>​        发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p>
<p>​        <strong>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）        识别出是非法的，于是就会提醒用户该证书存在问题。</strong></p>
<p>​        如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。所        以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己        手贱。</p>
<p>​        另外，如果电脑中毒被恶意导入了中间人的根证书，那么在验证中间人的证书由于操作系统信任中间人的根证书，等同于中间人的证        书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。这也不关 HTTPS 的事情，是电脑中毒才导致 HTTPS 数        据被中间人劫持。</p>
<p>​        所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继        续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<p><strong>问题2：HTTPS为什么能截取HTTPS数据？</strong></p>
<p>​        使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>​        抓包工具能够抓包的关键是<strong>客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是        抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的</strong>。</p>
<p><strong>问题3：如何避免被中间人抓取数据？</strong></p>
<p>​        通过 <strong>HTTPS 双向认证</strong>来避免问题。HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p>
<p>​        如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端        为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
<h2 id="TLS握手流程"><a href="#TLS握手流程" class="headerlink" title="TLS握手流程"></a>TLS握手流程</h2><p><em>1. ClientHello</em></p>
<p>由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。客户端主要向服务器发送信息：</p>
<p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p>
<p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p>
<p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p>
<p><em>2. SeverHello</em></p>
<p>服务器收到客户端请求后，向客户端发出响应 <code>SeverHello</code>。服务器回应的内容有：</p>
<p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p>
<p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p>
<p>（3）确认的密码套件列表，如 RSA 加密算法。</p>
<p>（4）服务器的数字证书。</p>
<p><em>3.客户端回应</em></p>
<p>客户端收到服务器的回应之后，通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p>
<p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>
<p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
<p><em>4. 服务器的最后回应</em></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>
<p>然后，向客户端发送最后的信息：</p>
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<h2 id="HTTP演变"><a href="#HTTP演变" class="headerlink" title="HTTP演变"></a>HTTP演变</h2><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p>
<ul>
<li>使用<strong>长连接</strong>的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li><strong>支持管道（pipeline）网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
<p>但 HTTP/1.1 还是有性能瓶颈：</p>
<ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<p> HTTP/2 相比 HTTP/1.1 性能上的改进：</p>
<ul>
<li><p>头部压缩：同时发出多个请求，他们的头是一样的或是相似的，协议会<strong>消除重复的部分</strong>。</p>
<p> 这就是 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。</p>
</li>
<li><p>二进制格式： 全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong></p>
</li>
<li><p>并发传输：</p>
<p>1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。<strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</p>
</li>
<li><p>服务器主动推送资源： 服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p>
</li>
</ul>
<p><strong>HTTP/2的缺陷</strong></p>
<p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题是在 TCP 这一层。</p>
<p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p>
<p>一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<p><strong>HTTP/3的出现</strong></p>
<p><img src="/assets/img/image-20230202221447367.png" alt="image-20230202221447367"></p>
<p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<p>QUIC 有以下 3 个特点。</p>
<ul>
<li>无队头阻塞：在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</li>
<li>更快的连接建立：HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，需要分批次来握手，先 TCP 握手，再 TLS 握手。HTTP/3 的 QUIC 协议内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</li>
<li>连接迁移：基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</li>
</ul>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>
<h2 id="HTTP-1-1优化"><a href="#HTTP-1-1优化" class="headerlink" title="HTTP/1.1优化"></a>HTTP/1.1优化</h2><p><strong>避免发送HTTP请求</strong></p>
<p>通过<strong>缓存技术</strong>。客户端会把第一次请求以及响应的数据保存在本地磁盘上，将请求的 URL 作为 key，而响应作为 value。当再次发起相同的请求时，先在本地磁盘上通过 key 查到对应的 value，如果找到了，直接从本地读取该响应。</p>
<p>服务器在发送 HTTP 响应时，响应头部带有过期时间，客户端在查看响应头部的信息时，发现缓存的响应过期，就重新发送网络请求。客户端在重新发送请求时，在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。</p>
<p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</p>
<p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。</p>
<p><strong>减少HTTP请求次数</strong></p>
<ul>
<li><strong>减少重定向请求次数。</strong>重定向请求越多，客户端就要多次发起 HTTP 请求。另外服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>。而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数。</li>
<li><strong>合并请求。</strong>把多个访问小文件的请求合并成一个大的请求，<strong>减少了重复发送的 HTTP 头部</strong>。HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送。为了防止单个请求的阻塞，所以<strong>一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接</strong>，那么如果合并了请求，也就会<strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间</strong>。</li>
<li><strong>延迟发送请求。</strong>通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数。没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源。</li>
</ul>
<p><strong>减少 HTTP 响应的数据大小</strong></p>
<p>对响应的资源进行<strong>压缩</strong>，可以减少响应的数据大小，从而提高网络传输的效率。</p>
<p>压缩的方式一般分为 2 种，无损和有损压缩。</p>
<p>无损压缩是 资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。生成二进制比特序列一般是「霍夫曼编码」算法。gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 <code>Accept-Encoding</code> 字段告诉服务器。</p>
<p>有损压缩，解压的数据会与原始数据不同但是非常接近。主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，经常用于压缩多媒体数据，音频、视频、图片。可以通过 HTTP 请求头部中的 <code>Accept</code> 字段里的「 q 质量因子」，告诉服务器期望的资源质量。图片的压缩，目前压缩比较高的是 Google 推出的 <strong>WebP 格式</strong>。</p>
<h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><p><strong>协议由来</strong></p>
<p>HTTP一般是基于TCP协议的。 TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p>
<p>TCP 收发二进制数据之间是<strong>没有任何边界</strong>的，根本不知道到哪个地方才算一条完整消息。因为没有<strong>任何边界</strong>，所以使用 TCP 发   送”夏”和”特烦恼”的时候，接收端收到的就是”夏洛特烦恼”，接收端没办法区分想要表达”夏洛”+”特烦恼”还是”夏洛特”+”烦恼”，这就是<strong>粘包问题</strong>。</p>
<p>所以TCP 不能直接拿来用，需要在基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。把每条要发送的数据都包装，加入<strong>消息头</strong>，<strong>消息头写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后就是真正要传输的<strong>消息体</strong>。<strong>消息头</strong>还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p>
<p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。<strong>基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p>
<p><strong>TCP 是传输层的协议</strong>，而基于 TCP 造出来的 HTTP 和<strong>各类</strong> RPC 协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。</p>
<p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）远程过程调用<strong>。它本身并不是一个具体的协议，而是一种</strong>调用方式**。远端服务器暴露出来的方法，还能像调用本地方法那样去调用它，这样屏蔽掉网络细节，用起来更方便。</p>
<p><strong>既然有 RPC 了，为什么还要有 HTTP 呢？</strong></p>
<p>​        电脑上的各种<strong>联网</strong>软件，都作为<strong>客户端（Client）需要跟服务端（Server）建立连接收发消息</strong>，这种 Client/Server (C/S) 架构，可以        使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 。</p>
<p>​        但浏览器（Browser）不同，要能访问所有的服务器，因此需要有个统一的标准，不然没法交流。HTTP 就是用于Browser/Server         (B/S)的协议。</p>
<p>​        多年以前，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构</strong>。</p>
<p><strong>HTTP和RPC的区别</strong></p>
<ul>
<li><p><strong>服务发现</strong>： 要向某个服务器发起请求，得先建立连接，而建立连接的前提是，知道 <strong>IP 地址和端口</strong>。找到服务对应的 IP 端口的过程，就是<strong>服务发现</strong>。在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong>去解析得到它背后的 IP 地址，默认 80 端口。 <strong>RPC</strong> 一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如 <strong>Consul 或者 Etcd，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。</p>
</li>
<li><p><strong>底层连接方式</strong>：<strong>HTTP/1.1</strong> 协议默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>Keep Alive</strong>），之后的请求和响应都会复用这条连接。<strong>RPC</strong> 协议也是通过建立 TCP 长链接进行数据交互，但RPC 协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>。</p>
</li>
<li><p><strong>传输的内容</strong>：基于 TCP 传输的消息，消息头 Header 和消息体 Body，Header用于标记一些特殊信息，其中最重要的是消息体长度，Body则放真正需要传输的内容，都是二进制数据。将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。消息头信息太过冗余，显得啰嗦。RPC，<strong>定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，性能也会更好一些。</strong></p>
</li>
</ul>
<h2 id="HTTP与WebSocket"><a href="#HTTP与WebSocket" class="headerlink" title="HTTP与WebSocket"></a>HTTP与WebSocket</h2><p><strong>服务器主动发消息给客户端的场景如何实现</strong>？</p>
<ul>
<li>使用HTTP不断轮询。<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong>最常见的就是<strong>扫码登录</strong>，以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。</li>
<li>长轮询。HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒， 30 秒内服务器收到了扫码请求，立马响应，超时就发起下一次请求，这样减少了 HTTP 请求的个数，并且大部分情况下，用户都会在某个30 秒的区间内做扫码操作，所以响应也是及时的。<strong>发起一个请求，在较长时间内等待服务器响应的机制，就是长训轮机制</strong>。消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</li>
<li>WebSocket。</li>
</ul>
<p><strong>WebSocket</strong></p>
<p> TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据，这是<strong>全双工</strong>.</p>
<p><code>HTTP/1.1</code>也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这是<strong>半双工</strong>。</p>
<p> HTTP 协议设计之初，考虑的是看看网页文本的场景，做到<strong>客户端发起请求再由服务器响应</strong>，根本就没考虑客户端和服务器之间都要互相主动发大量数据的场景。因此需要另外一个<strong>基于TCP的新协议</strong>–WebSocket。</p>
<p><strong>怎么建立WebSocket连接</strong></p>
<p>浏览器在 <strong>TCP 三次握手</strong>建立连接之后，<strong>统一使用 HTTP 协议</strong>进行一次通信。</p>
<ul>
<li>如果是<strong>HTTP 请求</strong>，那后续继续用HTTP 协议进行交互。</li>
<li>如果<strong>想建立 WebSocket 连接</strong>，就在 HTTP 请求里带上一些<strong>特殊的header 头</strong>：</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>

<p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>如果服务器正好支持升级成 WebSocket 协议，就走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols\r\n</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade\r\n</span><br></pre></td></tr></table></figure>

<p>HTTP 状态码101 ，指<strong>协议切换</strong>。</p>
<p>之后浏览器用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，则验证通过。</p>
<p>一来一回两次 HTTP 握手，WebSocket建立完成，后续双方使用 webscoket 的数据格式进行通信了。</p>
<p><strong>WebSocket的消息格式</strong></p>
<p>数据包在WebSocket中被叫做<strong>帧</strong>。重点关注字段：</p>
<p><strong>opcode字段</strong>：标志数据帧的类型。1 text类型（<code>string</code>）的数据包；2 二进制数据类型（<code>[]byte</code>）的数据包；8 关闭连接的信号</p>
<p><strong>payload字段</strong>：存放<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如发送的数据字符串”111”<code>，那它的长度就是</code>3`。用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p>
<p><strong>payload data字段</strong>：存放真正要传输的数据，在知道了payload长度后，可以根据这个值去截取对应的数据。</p>
<p><strong>WebSocket的使用场景</strong></p>
<p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力。</p>
<p>适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-02</span><i class="fa fa-tag"></i><a class="tag" href="/categories/计算机网络/" title="计算机网络">计算机网络 </a><a class="tag" href="/tags/计算机网络/" title="计算机网络">计算机网络 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2023/02/02/计算机网络-HTTP/,轻舟,计算机网络-HTTP,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/02/03/%E5%89%91%E6%8C%87offer11-12/" title="剑指offer11-12">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/02/02/%E5%89%91%E6%8C%87offer09-10/" title="剑指offer09-10">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>