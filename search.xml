<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer09-10</title>
      <link href="/2023/02/02/%E5%89%91%E6%8C%87offer09-10/"/>
      <url>/2023/02/02/%E5%89%91%E6%8C%87offer09-10/</url>
      
        <content type="html"><![CDATA[<h4 id="09、青蛙跳台阶问题"><a href="#09、青蛙跳台阶问题" class="headerlink" title="09、青蛙跳台阶问题"></a>09、青蛙跳台阶问题</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">限制:  0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// f(0)=1, f(1)=1,f(2)=2,</span></span><br><span class="line">        <span class="comment">// f(3)=f(1)+f(2)=3,f(4)=f(2)+f(3)=5,f(5)=f(3)+f(4)=8</span></span><br><span class="line">        <span class="comment">// 公式： f(n) = f(n-1)+ f(n-2)    n&gt;2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态规划  时间复杂度 O(n)</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[Math.max(n+<span class="number">1</span>, <span class="number">3</span>)];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i&lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 取余1000000007，保证值永远在int的范围内，防止溢出</span></span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>]+ dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b =<span class="number">1</span>, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 矩阵快速幂 时间复杂度 O(Logn)</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">power</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span>[][] base = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//注意传递值为n，不是n-1，与真正的斐波那契相比，多计算了一次幂</span></span><br><span class="line">        <span class="type">int</span>[][] res = getPower(base,power);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] getPower(<span class="type">int</span>[][] base,<span class="type">int</span> power)&#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示奇数</span></span><br><span class="line">            <span class="keyword">if</span>((power &amp; <span class="number">1</span>) ==<span class="number">1</span>)&#123;</span><br><span class="line">                ret = getMul(base,ret);</span><br><span class="line">            &#125;</span><br><span class="line">            base = getMul(base,base);</span><br><span class="line">            power&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] getMul(<span class="type">int</span>[][] a,<span class="type">int</span>[][] b)&#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                c[i][j] = (<span class="type">int</span>)(((<span class="type">long</span>)a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j] + (<span class="type">long</span>)a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j]) % <span class="number">1000000007</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、旋转数组的最小数字"><a href="#10、旋转数组的最小数字" class="headerlink" title="10、旋转数组的最小数字"></a>10、旋转数组的最小数字</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，称之为数组的旋转。</p><p>给一个可能存在 重复元素值的数组 numbers, 它原来是一个升序排列的数组，并按上述情形进行了一次旋转，请返回旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">n == numbers.length</span><br><span class="line">1 &lt;= n &lt;= 5000</span><br><span class="line">-5000 &lt;= numbers[i] &lt;= 5000</span><br><span class="line">numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="comment">// 原来就是升序数组,找旋转点【右排序数组的首个元素】,使用二分法降低复杂度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//   中间点 比 最右边的值大， 说明 旋转点在右侧，起点+1 </span></span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[end]) &#123;</span><br><span class="line">                start = mid +<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[end]) &#123;</span><br><span class="line">                <span class="comment">// 中间点比最右边的值小， 说明旋转点在左侧，终点 = 中间点</span></span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="comment">// 两值相等的情况，难以通过二分查询，可直接遍历比较得到最小值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number[start];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>start ; i&lt;=end; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (numbers[i] &lt; result) &#123;</span><br><span class="line">                        result = numbers[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer07-08</title>
      <link href="/2023/02/01/%E5%89%91%E6%8C%87offer07-08/"/>
      <url>/2023/02/01/%E5%89%91%E6%8C%87offer07-08/</url>
      
        <content type="html"><![CDATA[<h4 id="07、-重建二叉树"><a href="#07、-重建二叉树" class="headerlink" title="07、 重建二叉树"></a>07、 重建二叉树</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序边和中序遍历的结果中都不含重复的数字。</p><p>示例</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">限制：0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历： 根节点|左子树|右子树</span></span><br><span class="line">    <span class="comment">// 中序遍历： 左子树|根节点|右子树</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">// 哈希表存储中序遍历的值，降低查询复杂度</span></span><br><span class="line">        <span class="keyword">for</span>(init i=<span class="number">0</span>; i&lt; inorder.length; i++) &#123;</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件： 越过叶节点</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);</span><br><span class="line">        <span class="comment">// 找打根节点在中序遍历中对应的索引 i</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);</span><br><span class="line">        <span class="comment">// 建立左子树： 从前序遍历看，左子树根节点 root+1, </span></span><br><span class="line">        <span class="comment">//从中序遍历看，左子树左节点从 left开始，右节点到 i-1 结束, 长度 i-left</span></span><br><span class="line">        node.left = recur(root+<span class="number">1</span>, left, i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 建立右子树：前序遍历看,右子树根节点:根节点+左子树长度+1 -&gt; (root)+(i-left)+1</span></span><br><span class="line">        <span class="comment">//从中序遍历看，右子树左节点从 i+1 开始，右节点到 right 结束</span></span><br><span class="line">        node.right = recur(root+ i-left +<span class="number">1</span>, i+<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="09、用两个栈实现队列"><a href="#09、用两个栈实现队列" class="headerlink" title="09、用两个栈实现队列"></a>09、用两个栈实现队列</h4><p>用两个栈实现一个队列。队列的声明如下，实现它的两个函数 appendTail 和 deleteHead, 分别完成在队列尾部插入整数和在队列头部删除整数的功能（若队列中没有元素，deleteHead操作返回-1）.</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[],[]]</span><br><span class="line">输出：[null,null,3,-1,-1]</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; head;</span><br><span class="line">    LinkedList&lt;Integer&gt; tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">head = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         tail = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据到 tail</span></span><br><span class="line">        tail.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! head.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!tail.isEmpty()) &#123;</span><br><span class="line">            head.addLast(tail.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> head.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer05-06</title>
      <link href="/2023/01/31/%E5%89%91%E6%8C%87offer05-06/"/>
      <url>/2023/01/31/%E5%89%91%E6%8C%87offer05-06/</url>
      
        <content type="html"><![CDATA[<h4 id="05、替换空格"><a href="#05、替换空格" class="headerlink" title="05、替换空格"></a>05、替换空格</h4><p>实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"></span><br><span class="line">限制：0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (Character c : s.toCharArray()) &#123;</span><br><span class="line">            sb.append(c == <span class="string">&#x27; &#x27;</span>? <span class="string">&quot;%20&quot;</span>: c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="06、从尾到头打印链表"><a href="#06、从尾到头打印链表" class="headerlink" title="06、从尾到头打印链表"></a>06、从尾到头打印链表</h4><p>输入一个链表的头节点，从尾到头反过来用数组返回每个节点的值</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"></span><br><span class="line">限制：0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历链表，获取到链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成链表长度的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr= <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 链表赋值  1-&gt;3-&gt;4-&gt;2-&gt;5</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="comment">// 从数组最后一位开始赋值  0,0,0,0,0 -&gt; 0,0,0,0,1 -&gt; 0,0,0,3,1 .....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i&gt; -<span class="number">1</span>； i--) &#123;</span><br><span class="line">            arr[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-基础篇</title>
      <link href="/2023/01/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2023/01/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP/IP 网络模型"></a>TCP/IP 网络模型</h1><p>同一台设备进程间通信，可以通过管道、信号量、共享内存、消息队列，但不同设备的进程间通信需要网络通信，而设备是多样的，需要一套通用的网络协议。协议是分层的，每一层都有自己的作用和职责。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h3><p>Application Layer,  应用软件都在应用层。 应用层为用户提供应用功能，如 http、ftp、DNS、smtp等</p><p>工作在操作系统的应用态，将应用数据封装传输到传输层。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><strong>传输层</strong></h3><p>Transport Layer，为应用层提供网络支持。传输层有两个传输协议： TCP 和 UDP.</p><p>TCP 传输控制协议（Transmission Control Protocol）大多数应用使用的是 TCP传输协议，比如 HTTP 应用层协议。TCP 有众多特性，如 <strong>流量控制、超时重传、拥塞控制</strong>等，都是为了保证数据包能可靠的传输到对方。</p><p>UDP 只负责发送数据，不保证数据能否抵达，实时性好，传输效率高。UDP也可以实现可靠传输，把TCP特性在应用层实现就可以。</p><p>应用传输数据可能会很大，所以当传输层的数据包大小超过MSS(TCP最大报文段长度),要将数据包分块，即使途中某个块丢失或损坏，也只需要重新发送这一块。每一个小块叫一个TCP段。</p><p>设备作为接受方时，传输层把数据包传给应用，一台设备有很多应用在传输和接收数据，所以需要一个编号将应用分开，也叫端口。 80端口用作Web服务器, 22端口用作SSH，浏览器每一个Tab页都是独立进程，会临时分配一个端口号。<strong>传输层报文会携带端口号，所以接收方可以知道该报文是给哪个应用。</strong></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h3><p>实际的传输功能是在网络层发生。</p><p>一个设备数据传输到另一个设备，中间经历的网络环节错综复杂，有很多的路径和节点选择。</p><p>网络层常用的IP协议， <strong>IP协议将传输层报文作为数据部分，再加上IP包头组成IP报文，如果IP报文超过MTU（以太网中一般是1500字节）会再次进行分片，得到一个即将发送到网络的IP报文</strong>。</p><p>网络层区分设备的编号叫IP地址。 IPV4协议，IP地址总共有32位，分成4段， 每段8位。</p><p>IP地址能区分设备，但是不好寻址。所以 <strong>配合子网掩码把 IP地址分为两种， 一个是网络号，表示IP地址属于哪个子网， 一个是主机号，在子网中标识不同主机</strong>。</p><p><strong>IP地址 与子网掩码 按位与运算，得到网络号。</strong> </p><p><strong>子网掩码取反后 与 IP地址按位与云霄， 得到主机号。</strong></p><p>IP协议还负责路由， 路由器寻址工作中，要找到目标地址的子网，再把数据包转发到对应的网络内。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a><strong>网络接口层</strong></h3><p>生成IP头部后，交给 Link Layer, <strong>在IP头部的前面加上MAC头部，封装成数据帧发送到网络上。</strong></p><p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址可以判断将包发到哪里。</p><p>但是在以太网中也就是局域网中，WIFI接口、交换机、路由器网口中传输，无法通过IP头部进行传输，需要<strong>使用以太网中的MAC地址确定设备。 所以需要加上MAC头部，其中包括接收方和发送方的MAC地址信息，可以通过ARP协议获取对方的MAC地址。</strong></p><p>网络接口层是为 网络层提供 链路级别传输的服务。<strong>负责在以太网、wifi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标识网络上的设备。</strong></p><h1 id="键入网址到网页显示的过程"><a href="#键入网址到网页显示的过程" class="headerlink" title="键入网址到网页显示的过程"></a>键入网址到网页显示的过程</h1><h2 id="一-、-浏览器解析URL"><a href="#一-、-浏览器解析URL" class="headerlink" title="一 、 浏览器解析URL"></a>一 、 浏览器解析URL</h2><p>对URL进行解析，生成发送到web服务器的http请求报文。</p><p>http请求报文格式</p><ul><li>请求行： 方法 GET URL  /  版本 HTTP/1.1</li><li>消息头:  Accept ， UA,  refrere</li><li>消息体: 数据</li></ul><h2 id="二、DNA查询IP地址"><a href="#二、DNA查询IP地址" class="headerlink" title="二、DNA查询IP地址"></a>二、DNA查询IP地址</h2><p>浏览器先看自身有没有对域名的缓存，如果有，就直接返回，</p><p>如果没有，去问操作系统，操作系统看自己的缓存，如果有，就直接返回，</p><p>如果没有，去 hosts 文件看，</p><p>也没有，去问本地DNS服务器， 本地域名服务器去缓存的表格查找IP，有则返回。</p><p>没有就去根域名服务器，根域名服务器去问 顶级域名服务器 再问 权威域名服务器， 权威域名服务器会告诉IP地址，本地缓存然后告诉客户端。</p><h2 id="三、协议栈"><a href="#三、协议栈" class="headerlink" title="三、协议栈"></a>三、协议栈</h2><p><strong>DNS获取到IP后，HTTP的传输工作交给操作系统的协议栈。</strong></p><p>浏览器调用Socket库，委托协议栈工作。 </p><p>到达操作系统的协议栈中，先由收发数据的TCP和UDP协议，接收应用层的传输数据， </p><p>再由IP协议将数据变成一个个的网络包发送到网络。</p><p>IP中包括 ICMP 协议 和 ARP协议。</p><p>ICMP协议： 告知网络包传送过程中产生错误以及各种控制信息</p><p>ARP协议：根据IP地址查询相应的以太网MAC地址</p><p>IP下面就是网卡驱动程序，负责控制网卡硬件，而<strong>网卡负责实际的收发操作，也即是对网线中的信息执行发送和接收操作</strong>。</p><h2 id="四、TCP建立连接"><a href="#四、TCP建立连接" class="headerlink" title="四、TCP建立连接"></a>四、TCP建立连接</h2><p><strong>TCP包头格式</strong></p><p>源端口号16位，目的端口号16位，包序号32位（解决包乱序问题），</p><p>确认号（确认发出去对方是否有收到，没收到要重新发送，解决丢包问题），</p><p>状态位（SYN 标识发起一个连接，ACK标识回复，RST标识重新连接，FIN标识结束连接， TCP是面向连接的，双方维护连接状态，带状态位的包发送，引起双方状态变更），</p><p>窗口大小（TCP做流量控制，通信双方各声明一个窗口，也叫缓存大小，标识自己目前的处理能力， 还有就是 拥塞控制，控制自己的发送速度）</p><p><strong>TCP三次握手</strong></p><p>HTTP传输数据之前，要建立TCP连接，俗称三次握手。</p><p>连接就是在双方计算机中维护一个状态机，在连接建立的过程中，双方的状态变化：</p><ul><li>客户端和服务端都处于 close状态。先服务端主动监听某个端口，处于 Listen 状态。</li><li>客户端发起SYN：客户端的 seq num， 之后处于 SYN-SENT 状态</li><li>服务端收到发起的连接后，返回SYN ：服务端的 seq num , 并 ACK： 客户端的seq num +1, 之后处于 SYN_RECVD状态</li><li>客户端接收到服务端发送的 SYN+ACK 后， 发送对 SYN确认的ACK ： 服务端的seq num + 1, 之后处于 ESTABLISHED 状态</li><li>服务端收到 ACK 后， 处于establish 状态</li></ul><p><strong>三次握手目的是 保证双方都具备发送和接收的能力。</strong> </p><p><strong>TCP状态查看命令： <code>netstat -napt</code></strong></p><p><strong>TCP分割数据</strong></p><p>如果HTTP消息长，超过MSS(一个TCP段数据最大长度， 也就是 HTTP头部+消息体)， 需要TCP需要把HTTP数据分成一块块的数据，多次发送。</p><p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><strong>TCP报文生成</strong></p><p>TCP协议里面有两个端口，一个是浏览器的监听端口，一个是web服务器监听的端口。</p><p>在双方建立了连接后，TCP报文中的数据部分也就是 HTTP头部+数据，组装好TCP报文后，交给下面的网络层处理。</p><p><strong>一个网络包的报文包括   TCP头部 + HTTP报文</strong>。</p><h2 id="五、IP定位"><a href="#五、IP定位" class="headerlink" title="五、IP定位"></a>五、IP定位</h2><p>TCP在连接、收发、断开都需要经过IP模块将数据封装成网络包发送给通信对象。</p><p><strong>IP包头格式</strong></p><ul><li><p>源地址 IP（32位，客户端IP 地址） </p></li><li><p>目标地址 IP（32位，DNS 域名解析得到的 Web 服务器 IP）</p></li><li><p>协议号， （8位， HTTP是通过TCP传输，填写 06(十六进制)， 表示协议是TCP协议）</p></li><li><p>首部校验和 16位</p></li></ul><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p><p>根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p><p>Linux 操作系统，使用 <code>route -n</code> 命令查看当前系统的路由表。 </p><p>用web服务器的目的IP地址 逐条匹配路由表， 目的IP地址 与 子网掩码进行与运算，得到结果和 路由表的IP地址比较，如果匹配则作为源地址IP； 如果匹配不到，则有路由表有一条默认网关，会将包发送给路由器。</p></blockquote><h2 id="六、MAC两点传输"><a href="#六、MAC两点传输" class="headerlink" title="六、MAC两点传输"></a>六、MAC两点传输</h2><p>生成IP头部后，网络包还需要在IP头部前面加上MAC头部。</p><p><strong>MAC头部格式</strong></p><ul><li><p>接收方MAC 地址 （48位）</p></li><li><p>发送方MAC 地址（48位）</p></li><li><p>协议类型 （16位， 在TCP/IP 通信中一般有 0800： IP协议， 0806：ARP协议）</p></li></ul><blockquote><p>MAC发送方和接收方如何确认？</p><p>发送方的MAC地址是 在网卡生产时就写入ROM中，系统将值读出来就行</p><p>接收方的MAC地址：通过路由表找到匹配的条目，能拿到IP地址</p><p>IP地址如何获取MAC地址？</p><p><strong>使用ARP协议找到路由器的MAC地址</strong>。 <strong>ARP协议 在以太网中以广播方式，对所有以太网设备询问</strong>， IP地址是哪台设备的？把你的MAC地址告诉我。告诉本机后，<strong>系统把结果放到 ARP缓存中，所以在发包，先查ARP缓存，再根据情况是否发送ARP广播</strong>。</p></blockquote><p>Linux系统查看 ARP 缓存 命令：  arp -a` </p><h2 id="七、-网卡-出口"><a href="#七、-网卡-出口" class="headerlink" title="七、 网卡 出口"></a>七、 网卡 出口</h2><p>网络包是存放在内存中的一串二进制数字信息，需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输。</p><p>负责执行这一操作的是<strong>网卡</strong>，控制网卡需要靠<strong>网卡驱动程序</strong>。</p><p><strong>网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。</strong>将包转为电信号，通过网线发送出去。</p><h2 id="八、交换机-离开子网"><a href="#八、交换机-离开子网" class="headerlink" title="八、交换机 离开子网"></a>八、交换机 离开子网</h2><p>交换机作用是<strong>将网络包原样转发到目的地</strong>。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p><strong>交换机的包接收操作</strong></p><p>电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。</p><p>和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。将包存入缓冲区后，</p><p>接下来要<strong>查询包的接收方 MAC 地址是否已经在 MAC 地址表中有记录</strong>。</p><p>交换机的 MAC 地址表主要包含两个信息：一个是设备的 MAC 地址，另一个是该设备连接在交换机的哪个端口上。</p><p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>如果地址表中找不到指定的 MAC 地址。</p><p>可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p></blockquote><h2 id="九、路由器-出境大门"><a href="#九、路由器-出境大门" class="headerlink" title="九、路由器 出境大门"></a>九、路由器 出境大门</h2><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p><strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</p><p>路由器的端口具有 MAC 地址，因此它能成为以太网的发送方和接收方；同时还具有 IP 地址，某种意义上，和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><ul><li><p>电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p></li><li><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。<strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>然后路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p></li><li><p>转发操作，查询<strong>路由表</strong>判断转发目标，根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p></li><li><p>包的发送操作，根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li><p>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</p></li><li><p>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</p><p>知道对方的 IP 地址之后，需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。路由器也有 ARP 缓存，因此先在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p></li></ul><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p></li></ul><h2 id="十、服务端-与-客户端"><a href="#十、服务端-与-客户端" class="headerlink" title="十、服务端 与 客户端"></a>十、服务端 与 客户端</h2><p>数据包抵达服务器</p><p>服务器先扒开<strong>数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来</strong>。</p><p>继续扒开<strong>数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议</strong>。</p><p>扒开 <strong>TCP 的头，里面有序列号，看一看序列包是不是想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃</strong>。</p><p><strong>TCP头部里面有端口号， HTTP 的服务器正在监听这个端口号，于是将包发给 HTTP 进程</strong></p><p> HTTP 进程分析请求把结果<strong>封装在 HTTP 响应报文</strong>里。</p><p><strong>HTTP 响应报文穿上 TCP、IP、MAC 头部，源地址是服务器 IP 地址，目的地址是客户端 IP 地址</strong>。</p><p>穿好头部衣服后，<strong>再从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器</strong>。</p><p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。客户端收到了服务器的响应数据包后，开始扒皮，把<strong>收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面</strong>，网页就有显示了！</p><p>最后，<strong>客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了</strong>。</p><h1 id="Linux系统如何收发网络包"><a href="#Linux系统如何收发网络包" class="headerlink" title="Linux系统如何收发网络包"></a>Linux系统如何收发网络包</h1><p>Linux 系统按照TCP/IP 网络模型来实现网络协议栈的。</p><p>TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：</p><ul><li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</li><li>传输层，负责端到端的通信，比如 TCP、UDP 等；</li><li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</li><li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；</li></ul><h2 id="Linux-网络协议栈"><a href="#Linux-网络协议栈" class="headerlink" title="Linux 网络协议栈"></a>Linux 网络协议栈</h2><p>自己的身体比作应用层中的数据，</p><p>打底衣服比作传输层中的 TCP 头，</p><p>外套比作网络层中 IP 头，</p><p>帽子和鞋子分别比作网络接口层的帧头和帧尾。</p><p><strong>物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是 <code>1500</code> 字节，也就是规定了单次传输的最大 IP 包大小</strong>。</p><p><img src="/assets/img/image-20230130230447542.png" alt="image-20230130230447542"></p><h2 id="Linux-接收网络包的流程"><a href="#Linux-接收网络包的流程" class="headerlink" title="Linux 接收网络包的流程"></a>Linux 接收网络包的流程</h2><p>Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，核心就是 <strong>首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据</strong>。</p><p>当有网络包到达时，会<strong>通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区</strong>，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>硬件中断处理函数会做：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><p><strong>网络协议栈</strong></p><p>到达网络协议栈后，会先<strong>进入到网络接口层</strong>，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再<strong>去掉帧头和帧尾，然后交给网络层</strong>。</p><p>到了网络层，则<strong>取出 IP 包，判断网络包下一步的走向</strong>，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去<strong>掉 IP 头，然后交给传输层</strong>。</p><p><strong>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</strong></p><p>最后，<strong>应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程</strong>。</p><h2 id="Linux-发送网络包的流程"><a href="#Linux-发送网络包的流程" class="headerlink" title="Linux 发送网络包的流程"></a>Linux 发送网络包的流程</h2><ul><li>应用程序会调用 Socket 发送数据包的接口，这是系统调用，所以从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。</li><li>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong> ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每<strong>次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除</strong>。</li><li>对 sk_buff 填充 TCP 头。sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层称为 segment，在 IP 层叫 packet，在数据链路层称为 frame。</li><li><strong>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，通过调整 sk_buff 中 <code>data</code> 的指针实现的。当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</strong></li><li>到达网络层，网络层里执行：<strong>选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片</strong>。处理完后交给网络接口层。</li><li>网络接口层会<strong>通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中</strong>。</li><li>工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会<strong>触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存</strong>。最后，<strong>当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff</strong> 。</li></ul><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer03-04</title>
      <link href="/2023/01/30/%E5%89%91%E6%8C%87offer/"/>
      <url>/2023/01/30/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h4><p>在一个长度为n的数组nums中所有数字都是0~ n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。限制 2&lt;=n&lt;=10000</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure><p><strong>解答</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行原地交换。</span></span><br><span class="line"><span class="comment">// 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内， 说明数组元素的 索引 和 值 是 一对多 的关系， 因此遍历数组通过交换操作，使元素的索引和值一一对应，nums[1] = 1, 如果 nums[nums[1]] = 1, 说明数字重复。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">           <span class="comment">// 数字已在对应索引位置，无需交换，遍历下一个</span></span><br><span class="line">             <span class="keyword">if</span> (i == nums[i]) &#123;</span><br><span class="line">                 i++;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 索引 nums[i] 处 和 索引 i 处的元素值都为nums[i], 找到一组重复值</span></span><br><span class="line">             <span class="keyword">if</span> (nums[nums[i]] = nums[i]) &#123;</span><br><span class="line">                 <span class="keyword">return</span> nums[i];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 交换索引为i和nums[i]的元素值，将数字交换至对应索引位置</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums[i];</span><br><span class="line">             nums[i] = nums[j];</span><br><span class="line">             nums[j] = j;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h4><p>在一个 n*m的二维数组中，每一行都按照从左到右 <strong>非递减</strong>的顺序排列，每一列都按照从上到下 <strong>非递减</strong>的顺序排序。请完成一个高效函数，输入这样的一个二维数组和一个整数，判断数组是否含有该整数。</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line">给定 target = 20，返回 false。</span><br><span class="line"></span><br><span class="line">限制： 0 &lt;= n &lt;= 1000    0 &lt;= m &lt;= 1000</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><p><img src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 利用 从上到下递增，从左到右递增的特点，将矩阵逆时针旋转45°，将其转换成类似二叉搜索树，</span></span><br><span class="line"><span class="comment">对于每个元素，其左分支元素更小、右分支元素更大。</span></span><br><span class="line"><span class="comment">通过从 根节点开始搜索，遇到比 target 大的元素就向左， 反之则向右， 即可找到target</span></span><br><span class="line"><span class="comment">“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，也叫标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:</span></span><br><span class="line"><span class="comment">若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</span></span><br><span class="line"><span class="comment">若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                 i--;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                 j++;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2023/01/30/spring/"/>
      <url>/2023/01/30/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring循环依赖"><a href="#spring循环依赖" class="headerlink" title="spring循环依赖"></a>spring循环依赖</h1><h2 id="循环依赖定义"><a href="#循环依赖定义" class="headerlink" title="循环依赖定义"></a>循环依赖定义</h2><p>一个或多个对象之间存在直接或者间接的依赖关系，这种依赖关系是一个环形调用。</p><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>spring内部有三级缓存：</p><ul><li>第一级缓存： singletonObjects，用于保存实例化、注入、初始化完成的bean示例</li><li>第二级缓存：earlySingletonObjects, 用于保存实例化完成的bean示例</li><li>第三级缓存：singletonFactories, 用于保存bean创建工厂，以便后面有机会创建代理对象</li></ul><p><strong>执行逻辑</strong>： </p><p>一级缓存找对象，找不到去二级缓存，再找不到去三级缓存，找到了，获取对象，放到二级缓存，从三级缓存中移除。</p><p><img src="/assets/img/image-20230129102642561.png" alt="image-20230129102642561"></p><h2 id="原理执行流程"><a href="#原理执行流程" class="headerlink" title="原理执行流程"></a>原理执行流程</h2><p>第一层： 先获取A的bean, 发现没有则去创建，然后找到A的代理工厂放入三级缓存（这时A其实是半成品，还没有对里面的属性进行注入），但是A依赖B的创建，所以先去创建B；</p><p>第二层：准备创建B， 发现B又依赖A，需要先去创建A；</p><p>第三层： 去创建A，因为第一层一级创建A的代理工厂，直接从三级缓存中拿到A的代理工厂，获取A的代理对象，放到二级缓存中，并清除三级缓存；</p><p>回到第二层，现在有了A的代理对象，对A的依赖解决（此时A还是半成品），B初始化成功；</p><p>回到第一层，现在B初始化成功，完成A对象的属性注入，再填充A的其他属性，以及A的其他步骤（包括AOP），完成对A完整的初始化功能（此时A是完整的Bean）；</p><p>将A放入一级缓存。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>refresh方法中的 finishBeanFactoryInitialization(beanFactory)方法： 实例化所有bean工程缓存的bean对象。</p><p>进入 beanFactory.preInstantiateSingletons()方法： 实例化剩下的所有的单例对象。</p><p><strong>第一层</strong>：</p><p> 进入 doGetBean()，从 getSinleton()没有找到对象，</p><p>进入创建bean的逻辑，调用 createBean(beanName, mbd, args)， </p><p>进入doCreateBean() 后，调用 addSingletonFactory(), 往 三级缓存 singletonFactoies塞入工厂对象</p><p>进入 populateBean(), 执行 postPrecessProperties() 这是一个策略模式，使用 AutowiredAnnotationBeanPostProcessor</p><p>进入  metadata.inject(bean, beanName, pvs) , 再进入 element.inject(target, beanName, pvs) ， 进入 resolveFieldValue()对成员对象进行属性注入, </p><p>进入 beanFactory.resolveDependency(), 再进入 doResolveDependency(), 找到 对象A 依赖的对象名 B</p><p>获取B的bean, 进入  resolveCandidate()  ，这是 AbstratBeanFactory的方法 ， 调用 beanFactory.getBean获取到B的bean</p><p><strong>第二层</strong>：</p><p>获取到B的bean，从doGetBean(), 到 doResplveDependency() 和第一层逻辑完全一样，找到 B依赖的对象名A</p><p>进入  resolveCandidate()， 调用 beanFactory.getBean获取到A的bean</p><p><strong>第三层</strong></p><p>获取A的bean，在第一层和第二层中，每次都会从getSingleton()获取对象，但是由于之前没有初始化 A 和 B 的三级缓存，所以获取对象为空。</p><p>进入 doGetBean()， 调用 getSingleton()获取对象，  由于第三级缓存有 A 数据，这里使用三级缓存的工厂，为A创建一个代理对象，塞入二级缓存，将三级缓存的工厂删除。</p><p>此时已经拿到A的代理对象，解决了B的依赖关系，返回到第二层。</p><p><strong>返回第二层</strong></p><p>在doGetBean() 中， 通过 createBean() 创建一个B的bean, 当B的bean创建成功后，会执行  getSingleton() 对B的结果进行处理；</p><p>在getSingleton方法中调用 addSingleton方法， 处理 B的一、二级缓存的逻辑，将二级缓存清除，放入一级缓存</p><p><strong>返回第一层</strong></p><p>A初始化完成后，会将 A的二级缓存清除，将对象放入一级缓存。</p><h2 id="为什么有三级缓存"><a href="#为什么有三级缓存" class="headerlink" title="为什么有三级缓存"></a>为什么有三级缓存</h2><p>一级缓存，singletonObjects, 结构是 Map&lt;String, Object&gt; ，这是一个单例池，将初始化好的对象放到里面，给其他线程使用，如果没有第一级缓存，程序不能保证Spring的单例属性。</p><p>三级缓存， singletonFactories, 结构是 Map&lt;String, ObjectFactory&lt;?&gt;&gt; , Map的Value是一个对象的代理工厂，三级缓存的作用是存放对象代理工厂。</p><p> 对象代理工厂主要是存放半成品的单例Bean, 目的是为了打破循环。</p><p><strong>三级缓存为什么不直接存半成品的A，而是一个代理工厂？</strong></p><p>因为AOP。</p><p>对象工厂是如何得到的？ 在addSingletonFactory方法中调用 AbstractAutoProxyCretor 的 getEarlyBeanReference方法， 再调用 wrapIfNecessary方法，判断bean是否有AOP, 有则创建一个代理对象，无则返回原对象。</p><p>二级缓存： 用来存放对象工厂生成的对象，这个对象可能是原对象，也可能是代理对象。</p><p><strong>能不能去掉二级缓存</strong></p><p>如果 A 需要找 B 和 C，但是 B 需要找 A，C 也需要找 A。</p><p><strong>假如</strong> <strong>A</strong> <strong>需要进⾏</strong> <strong>AOP</strong>，因为代理对象每次都是⽣成不同的对象，如果⼲掉第⼆级缓存，只有第⼀、三级缓存：</p><p>B 找到 A 时，直接通过三级缓存的⼯⼚的代理对象，⽣成对象 A1。</p><p>C 找到 A 时，直接通过三级缓存的⼯⼚的代理对象，⽣成对象 A2。</p><p>通过A的⼯⼚的代理对象，⽣成了两个不同的对象A1和A2，</p><p>所以⼆级缓存的⽬的是为了避免因为AOP创建多个对象，其中存储的是半成品的AOP的单例bean。</p><p>如果没有 AOP 的话，只要 1、3 级缓存，就可以满⾜要求。</p><p>作用</p><p>⼀级缓存：为Spring的单例属性⽽⽣，就是个单例池，⽤来存放已经初始化完成的单例 Bean；</p><p>⼆级缓存：为解决AOP⽽⽣，存放的是半成品的 AOP 的单例 Bean；</p><p>三级缓存：为打破循环⽽⽣，存放的是⽣成半成品单例 Bean 的⼯⼚⽅法</p><h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><h2 id="IOC定义"><a href="#IOC定义" class="headerlink" title="IOC定义"></a>IOC定义</h2><p>控制反转，把创建对象的权利交给容器，由容器控制所有的对象。</p><p>IOC体现了面向对象设计法则-好莱坞法则： 别找我们，我们找你。 由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><p>控制： 谁控制谁？IOC容器控制对象</p><p>反转： 为何反转？由容器帮我们查找并注入依赖对象，对象只是被动接受依赖对象。 哪些方面反转？依赖对象的获取被反转了。</p><h2 id="Bean生命周期-1"><a href="#Bean生命周期-1" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p>对Prototype Bean来说，当用户getBean获取到 Prototype Bean实例后，IOC容器就不再对当前实例进行管理，而是把管理权交给用户，此后再getBean生成的是新的实例。所以 描述Bean的生命周期，指的是 Singleton Bean。</p><p><img src="/assets/img/image-20230128165927001.png" alt="image-20230128165927001"></p><p>Bean生命周期过程：</p><ul><li>实例化： 实例化一个Bean对象</li><li>属性赋值：为Bean设置相关属性和依赖</li><li>初始化：5、6 步是真正的初始化，第 3、4 步为在初始化前执⾏，第 7 步在初始化后执⾏，初始化完成之后，Bean 就可以被使⽤了</li><li>销毁： 第 8~10 步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，⽽是先在使⽤前注册了销毁的相关调⽤接⼝，为了后⾯第 9、10 步真正销毁 Bean 时再执⾏相应的⽅法。</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul><li>调用构造方法: 出生了</li><li>设置属性： 名字叫小夏</li><li>BeanNameAware#setBeanName： 要上学了，学名叫 夏夏</li><li>BeanFactoryAware#setBeanFactory： 选好学校了</li><li>BeanPostProcessor.postProcessBeforeInitialization： 到学校报名了</li><li>InitializingBean#afterPropertiesSet：入学登记</li><li>自定义init： 努力上学ing</li><li>BeanPostProcessor#postProcessAfterInitialization: 毕业，拿到毕业证了</li><li>Bean使用中： 工作，</li><li>DisposableBean#destory： 人生落幕</li><li>自定义destory方法： 长眠于此</li></ul><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><ul><li>Aware接口：让Bean能拿到容器的一些资源，例如 BeanNameAware的setBeanName, BeanFactoryAware的 setBeanFactory</li><li>后处理器：进行一些前置和后置的处理， 例如 BeanPostProcessor的 postProcessBeforeInitialization , postProcessAfterInitialization</li><li>生命周期接口：定义初始化方法和销毁方法， 例如 InitializingBean的 afterPropertiesSet, DisposableBean 的 destory</li><li>配置生命周期方法： 通过配置文件，自定义初始化和销毁方法，例如配置文件配置的init 和 destoryMethod</li></ul><h2 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h2><p>进入 doGetBean()，从 getSingleton() 没有找到对象，进⼊创建 Bean 的逻辑</p><p><strong>实例化</strong></p><p>进⼊ doCreateBean() 后，调⽤ createBeanInstance()，调⽤ instantiateBean()， 调用 getInstantiationStrategy.instantiate()， 调用 BeanUtils.instantiateClass(), 调用 newInstance(), 实例化 Bean.</p><p> <strong>属性赋值</strong></p><p>回到 doCreateBean() ，进入 populateBean()【此方法是依赖注入的逻辑】, 执行 applyPropertyValues(),  后执行 bw.setPropertyValues(), 进入 processLocalProperty()，执行 ph.setValue()，调用 writeMethod.invoke，进入 Bean的方法，给Bean赋值name。</p><p><strong>初始化</strong></p><p>回到 doCreateBean()， 执行 initializeBean(),  </p><p>进入 invokeAwareMethods, 调用 setBeanName, 会进入Bean的 setBeanName(),  设置BeanName, </p><p>回到invokeAwareMethods, 调用 setBeanFactory, 会进入Bean的 setBeanFacroty, 设置 BeanFacroty</p><p>第一次回到 initializeBean， 进入 applyBeanPostProcessorsBeforeInitialization, 找到 MyBeanPostProceeor的策略方法，执行自定义的前置处理方法</p><p>第二次回到 initializeBean，进入 invokeInitMethods, 调用 afterPropertiesSet, 会进入Bean的 afterPropertiesSet</p><p>回到 invokeInitMethods， 继续执行 invokeCustomInitMethod, 调用 methodToInvoke.invoke, 进入 Bean的 init()</p><p>第三次回到 initializeBean， 进入 applyBeanPostProcessorsAfterInitialization, 找到 MyBeanPostProceeor的策略方法，执行自定义的后置处理方法.</p><p><strong>销毁</strong></p><p>destory方法，调用 close方法， 执行 doClose(), </p><p>进入doClose(), 调用 destoryBeans(), 调用 getBeanFactory.destorySingletons(),  </p><p>调用 destoryBean(), 调用 bean.destory(), 会进入到 Bean, 调用 destory()</p><p>再执行 invokeCustomDestoryMethod, 调用 destoryMethod.invoke， 会进入到 Bean, 调用 destoryMethod()</p><p><strong>重要方法</strong></p><ul><li><p>doCreateBean()：这个是⼊⼝；</p></li><li><p>createBeanInstance()：⽤来初始化 Bean，⾥⾯会调⽤对象的构造⽅法；</p></li><li><p>populateBean()：属性对象的依赖注⼊，以及成员变量初始化；</p></li><li><p>initializeBean()：⾥⾯有 4 个⽅法，</p></li></ul><p>​        先执⾏ aware 的 BeanNameAware、BeanFactoryAware 接⼝；</p><p>​        再执⾏ BeanPostProcessor 前置接⼝；</p><p>​        然后执⾏ InitializingBean 接⼝，以及配置的 init()；</p><p>​        最后执⾏ BeanPostProcessor 的后置接⼝。</p><ul><li>destory()：先执⾏ DisposableBean 接⼝，再执⾏配置的 destroyMethod()。</li></ul><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>aop定义</p><p>aspect oriented programming 面向切面编程，在AOP的思想里面，周边功能（日志、事务管理、性能统计）被定义为切面，核心功能和切面功能单独开放，把 核心功能 和切面功能编织在一起，这就是AOP。</p><p>AOP 将与业务无关，却为业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p><p>连接点(Join point)：能够被拦截的地⽅，Spring AOP 是基于动态代理的，所以是⽅法拦截的，每个成员⽅法都可以称之为连接点；</p><p>切点(Poincut)：每个⽅法都可以称之为连接点，我们具体定位到某⼀个⽅法就成为切点；</p><p>通知(Advice)：表示添加到切点的逻辑代码并定位连接点的⽅位信息，简单来说就定义了是⼲什么的，具体是在哪⼲；</p><p>织⼊(Weaving)：将增强/通知添加到⽬标类的具体连接点上的过程；</p><p>引介(Introduction)：允许我们向现有的类添加新⽅法或属性，是⼀种特殊的增强；</p><p>切⾯(Aspect)：切⾯由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</p><p>切⼊点Pointcut：在哪些类，哪些⽅法上切⼊（<strong>where</strong>）；</p><p>通知Advice：在⽅法执⾏的什么时机when， 做什么what：增强的功能；</p><p>切⾯（Aspect）：切⾯ = 切⼊点 + 通知，通俗点就是在什么时机，什么地⽅，做什么增强；</p><p>织⼊（Weaving）：把切⾯加⼊到对象，并创建出代理对象的过程，这个由 Spring 来完成。</p><p>5 种通知的分类：</p><p>前置通知(Before Advice)：在⽬标⽅法被调⽤前调⽤通知功能；</p><p>后置通知(After Advice)：在⽬标⽅法被调⽤之后调⽤通知功能；</p><p>返回通知(After-returning)：在⽬标⽅法成功执⾏之后调⽤通知功能；</p><p>异常通知(After-throwing)：在⽬标⽅法抛出异常之后调⽤通知功能；</p><p>环绕通知(Around)：把整个⽬标⽅法包裹起来，在被调⽤前和调⽤之后分别调⽤通知功能。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/assets/img/image-20230128180630653.png" alt="image-20230128180630653"></p><p>分为三块：</p><ul><li><p>前置处理，在创建 Louzai Bean 的前置处理中，遍历程序所有的切⾯信息，将切⾯信息保存在缓存中。</p></li><li><p>后置处理，在创建Bean的后置处理器中</p><ul><li><p>获取 Bean的切⾯⽅法：从缓存中拿到所有的切⾯信息，和 Bean 的所有⽅法进⾏匹配，然后找到</p><p>Bean 所有需要进⾏ AOP 的⽅法。</p></li><li><p>创建AOP代理对象**：结合 Bean 需要进⾏ AOP 的⽅法，选择 Cglib 或 JDK，创建 AOP 代理对象。</p></li></ul></li><li><p>执行切面， 通过 责任链+递归的方式，去执行切面</p></li></ul><h2 id="源码解读-2"><a href="#源码解读-2" class="headerlink" title="源码解读"></a>源码解读</h2><p>在doGetBean()，进⼊创建 Bean 的逻辑，进入 createBean(),</p><p><strong>前置处理</strong></p><p> 前置入口 ： resolveBeforeInstantiation(),  调用 applyBeanPostProcessorsBeforeInstantiation()  进行前置处理， </p><p>进入方法 postProcessBeforeInstantiation() ，进入 shouldSkip(), 进入findCandidateAdvisors() 获取切面信息，</p><p>进入buildAspectJAdvisors()， </p><pre><code>1. 遍历所有的类， 1. 判断是否切面，调用 isAspect(), 调用 hasAspectAnnotation，是否有Aspect注解1. 获取每个Aspect的切面列表 getAdvisors()。getAdvisor() 生成切面信息1. 保存Aspect的切面列表到缓存advisorsCache中。</code></pre><p><strong>后置处理</strong></p><p>从缓存拿切面，和bean的方法匹配，并创建 AOP代理对象。</p><p>后置入口 ： doCreateBean(), 进入 initializeBean(), 调用 applyBeanPostProcessorsAfterInitialization 进行后置处理</p><p>进入方法 postProcessBeforeInstantiation() ，进入 wrapIfNecessary()，</p><ul><li>获取到bean类的所有切面列表， getAdvicesAndAdvisorsForBean()</li><li>创建一个AOP的代理对象., createProxy(), 调用 createAopProxy().getProxy(), 这里有两种创建代理对象的方式<ul><li>Cglib创建代理对象</li><li>通过JDK动态代理创建代理对象</li></ul></li></ul><p><strong>切面执行</strong></p><p>拿到 AOP代理对象执行调用 service 的方法。</p><p>设计思路：采⽤递归 + 责任链的模式；</p><p>递归：反复执⾏ CglibMethodInvocation 的 proceed()；</p><p>退出递归条件：interceptorsAndDynamicMethodMatchers 数组中的对象，全部执⾏完毕；</p><p>责任链：有一个对象数组，每次取其中⼀个数组对象，然后去执⾏对象的invoke（）。</p><p>第一次递归：数组第一个对象是 ExposeInvocationInterceptor执行invoke(),啥也没干，继续执行 CglibMethodInvocation 的 proceed()。</p><p>第二次递归：数组第二个对象是 MethodBeforeAdviceInterceptor执行invoke(),会执行到自定义的前置通知方法。</p><p>第三次递归：数组第三个对象是AfterReturningAdviceInterceptor执行invoke()，退出递归 invokeJoinpoint()。</p><p>invokeJoinpoint() 执行主方法，也就是 service切面的方法。</p><p>执行完成后，第四次递归，会执行到自定义的后置通知方法。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>切面执行的责任链模式并不纯粹。 纯粹的责任链模式，对象内部有一个自身的next对象，执行完当前对象的方法末尾，就会启动next对象的执行，直到最后一个next对象执行完毕，或者途中因为某些条件中断执行，责任链才会退出。</p><p>而这里的 CglibMethodInvocation对象内部没有next对象，全程通过 interceptorsAndDynamicMethodMatchers的数组控制，依次去执行数组中的对象，直到最后一个对象执行完毕，责任链才会退出。</p><p>主对象是 CglibMethodInvocation, 继承于 ReflectiveMethodInvocation， 然后 process的核心逻辑，其实都是在 ReflectiveMethodInvacation中。</p><p>ReflectiveMethodInvocation 的 process() 控制整个责任链的执行。所有数组的对象都继承MethodInterceptor接口。</p><p>然后每次执行invoke()时，里面都会去执行 CglibMethodInvocation的process()。</p><p><strong>对象和方法的关系</strong>：</p><ul><li>接口继承： 数组中的对象都继承MethodInterceptor接口，实现里面的invoke方法</li><li>类继承： 主对象CglibMethodInvocation，继承于ReflectiveMethodInvocation， 复用它的 process()方法</li><li>两者结合（策略模式）： invoke的入参，就是CglibMethodInvocation，执行invoke时，内部会执行CglibMethodInvocation.process()</li></ul><p><strong>执行逻辑</strong></p><p>程序⼊⼝：是 CglibMethodInvocation 的 process() ⽅法；</p><p>链式执⾏（衍⽣的责任链模式）：process() 中有个包含 3 个对象的数组，依次去执⾏每个对象的 invoke() 。</p><p>递归（逻辑回退）：invoke() ⽅法会执⾏切⾯逻辑，同时也会执⾏ CglibMethodInvocation 的 process() ⽅法，让逻辑再⼀次进⼊ process()。</p><p>递归退出：当数组中的对象全部执⾏完毕，流程结束。</p><p>所以这⾥设计巧妙的地⽅，是因为纯粹责任链模式，⾥⾯的 next 对象，需要保证⾥⾯的对象类型完全相同。但是数组⾥⾯的对象，⾥⾯没有 next 成员对象，所以不能直接⽤责任链模式，那怎么办呢？就单独搞了⼀个CglibMethodInvocation.process()，通过去⽆限递归 process()，来实现责任链的逻辑。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h2><p>spring事务源码分为两块，</p><p><img src="/assets/img/image-20230128205806835.png" alt="image-20230128205806835"></p><p>入口是 refresh(), 执行 doCreateBean().</p><p><strong>第一部分： 后置处理</strong>，</p><p>在创建 Bean 的后置处理器中，会做两件事： </p><ol><li>获取Bean的切面方法：首先会拿到所有的切面信息，和 Bean的所有方法进行匹配，然后找到Bean所有需要进行事务处理的方法，匹配成功的方法，还需要将事务属性保存到缓存 attributeCache中</li><li>创建AOP代理对象：结合Bean需要进行AOP的方法，选择Cglib或JDK，创建AOP代理对象</li></ol><p><strong>第二部分：事务执行</strong></p><p><img src="C:\Users\xia\AppData\Roaming\Typora\typora-user-images\image-20230128210230989.png" alt="image-20230128210230989"></p><p>从缓存中拿到事务属性、创建并开启事务、执行业务逻辑、提交或回滚事务。</p><h2 id="源码解读-3"><a href="#源码解读-3" class="headerlink" title="源码解读"></a>源码解读</h2><p>进⼊ doGetBean()，进⼊创建 Bean 的逻辑。 进⼊ createBean()，调⽤ doCreateBean()。进⼊ doCreateBean()，调⽤ initializeBean()。</p><p>进入 initializeBean(), 调用 applyBeanPostProcessorsAfterInitialization() ，调用 wrapIfNecessary()。</p><p>wrapIfNecessary() 是用来创建代理对象， 同时也是入口。</p><p><strong>创建代理对象</strong></p><ul><li><p>先获取bean类的所有切面列表， 进⼊ canApply()，开始匹配 bean 的切⾯, 遍历所有的方法，进行匹配，</p><p>getTransactionAttribute() 获取事务属性， 调用 parseTransactionAnnotation获取 element对象中的 @Transactional注解，得到事务属性，匹配成功， 会把事务的属性配置信息放入attributeCache缓存。</p></li><li><p>创建一个AOP的代理对象，createProxy().</p></li></ul><p><strong>事务执行</strong></p><p>回到业务逻辑，通过 bean的aop代理对象，执行主方法，因为代理对象是Cglib方式创建，所有通过 intercept()执行。</p><p>new CglibMethodInvocation 调用 proceed()方法，执行 invokeWithinTransaction方法。</p><p>invokeWithinTransaction是事务执行的核心逻辑。</p><ol><li>获取事务属性， getTransactionAttribute 从 attributeCache获取事务的缓存数据</li><li>创建事务， createTransactionIfNecessary() 中 先获取 事务状态（ getTransaction()）, 再将事务状态和事务属性等信息封装成一个TransactionInfo对象。</li><li>获取事务 doGetTransaction() , 创建数据源事务对象（new DataSourceTransactionObject ）, 是否允许当前事务设置保持点（setSavepointAllowed），TransactionSynchronizationManager 事务同步管理器对象(该类中都是局部线程变量)⽤来保存当前事务的信息,第⼀次从这⾥去线程变量中获取 事务连接持有器对象 通过数据源为key去获取。</li><li>开启事务 startTranscation() , 调用 doBegin()【 强制装化事务对象， 判断事务对象没有数据库连接持有器，通过数据源获取一个数据库连接对象，把数据库连接包装成ConnectionHolder对象，设置到事务对象中，标记当前的连接是一个同步事务，为事务设置隔离级别，关闭自动提交，判断事务只读，设置事务激活，设置事务超时时间， 绑定数据源和连接到同步管理器上，把数据源作为key,数据库连接作为value, 设置到线程变量中， 释放数据库连接】</li><li>执行业务逻辑 proceedWithInvocation() –&gt;proceed() –&gt;invokeJoinpoint() –&gt;invoke()</li><li>回滚事务 complateTransactionAfterTrowing ,  getTransactionManager().rollback()执行回滚逻辑， rollbackOn() , 如果抛出的异常类型和事务定义的异常类型匹配，证明该异常需要捕获，事务进行回滚。</li></ol><h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><h2 id="IOC定义-1"><a href="#IOC定义-1" class="headerlink" title="IOC定义"></a>IOC定义</h2><p>IOC不是一种技术而是一种思想，直到设计松耦合的程序。</p><p>传统应用由类内部主动创建依赖对象，导致类和类之间高耦合，而IOC容器被创建和查找依赖对象的控制权交给容器，由容器进行注入组合对象，所以对象和对象之间是松散耦合，便于功能复用，结构更灵活。</p><p>IOC容器控制对象，控制了外部资源获取。</p><p>容器帮我们查找和注入依赖对象，对象只是被动接受依赖对象，所以是反转，依赖对象的获取反转了。</p><h2 id="容器创建过程"><a href="#容器创建过程" class="headerlink" title="容器创建过程"></a>容器创建过程</h2><p>Spring IOC 是存储、定制、管理等功能的各种定制化的bean对象容器。</p><p><img src="/assets/img/image-20230128222114195.png" alt="image-20230128222114195"></p><h2 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h2><ul><li><p>ApplicationContext</p><p>ApplicationContext接口是BeanFactory的子接口，也被称为 spring上下文，和 BeanFactory一样，可以加载配置文件中定义的bean，并进行管理。 还加强了其他功能，如从属性文件中解析文本信息和将时间传递给所有指定的监视器。</p><p><img src="/assets/img/image-20230128222552943.png" alt="image-20230128222552943"></p></li></ul><p>​        ApplicationContext 接⼝主要的 5 个作⽤如表所示：</p><p><img src="/assets/img/image-20230128222612350.png" alt="image-20230128222612350"></p><ul><li><p>BeanDefinitionReader</p><p>配置文件解析器，如将配置文件中bean信息解析成对应的BeanDefinition对象。</p><p>xml文件解析使用的是 BeanDefinitionReader实现类XmlBeanDefinitionReader。</p></li><li><p>BeanFactoryPostProcessor</p><p>可以修改spring上下文中 BeanDefinition 信息。如 BeanFactoryPostProcessor的子类 PropertySourcesPlaceholderConfigurer的作用可以为数据库连接池${}占位符赋值</p></li><li><p>BeanFactory</p><p>所有bean容器的根接口，定义了容器的基本方法， 如 getBean() 通过 类、对象名、类+对象、对象名+对象获取bean 对象， getType 获取类型， containsBean 是否有此类， isSingleton 是否为单例等等</p></li></ul><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p>容器初始化的核心代码都在 refersh()中。</p><p><img src="/assets/img/image-20230128223437716.png" alt="image-20230128223437716"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><strong>prepareRefresh()</strong> </p><p>准备刷新上下文环境。 </p><p>initPropertySources() 初始化上下文环境；</p><p>getEnvironment().validateRequiredProperties() 校验我们容器启动必须依赖的环境变量的值</p><p>earlyApplicationListeners 创建⼀个早期事件监听器对象， 并加入到 applicationListeners 中</p><p> this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;() 创建容器⽤于保存早期待发布的事件集合（事件监听器还没有注册到事件多播器上的时候都称为早期事件）</p><p><strong>ConfigurableListableBeanFactory()</strong></p><p>获取初始化的Bean的工厂。</p><p>refreshBeanFactory() : 由于BeanFactory只能刷新⼀次，多线程情况下可能导致线程安全问题，所有使⽤cas原⼦操作来保证</p><p> this.beanFactory.setSerializationId(getId()) 指定Bean⼯⼚的序列化Id</p><p>返回之前容器准备⼯作的时候创建的的bean⼯⼚也就是DefaultListableBeanFactory</p><p><strong>prepareBeanFactory()</strong></p><p>对 Bean ⼯⼚进⾏填充属性.</p><p> beanFactory.setBeanClassLoader(getClassLoader()) 设置bean⼯⼚的类加载器为当前application应⽤上下⽂的加载器</p><p> beanFactory.setBeanExpressionResolver(newStandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); ⼯⼚设置SPEL表达式解析器对象</p><p> beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this,getEnvironment())); bean⼯⼚设置了⼀个propertyEditor属性资源编辑器对象(⽤于后⾯的给bean对象赋值使⽤)</p><p> beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); 注册ApplicationContextAwareProcessor后置处理器⽤来处理ApplicationContextAware接⼝的回调⽅法</p><p>ignoreDependencyInterface  当Spring将ApplicationContextAwareProcessor注册后，那么在invokeAwarelnterfaces⽅法中调⽤的Aware类已经不是普通的bean了, 如ResourceLoaderAware、ApplicationEventPublisherAware、ApplicationContextAware等，那么当然需要在Spring做bean的依赖注⼊的时候忽略它们。</p><p>registerResolvableDependency 注册了依赖解析，例如当注册BeanFactory.class的解析依赖后，当bean的属性注⼊的时候，⼀旦检测到属性为BeanFactory类型便会将beanFactory的实例注⼊进去。</p><p>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); 注册了⼀个事件监听器探测器后置处理器接⼝</p><p> <strong>postProcessBeanFactory()</strong></p><p>Spring 开放接⼝留给⼦类去实现该接⼝，主要⽤来改变 BeanFactory。</p><p>如给 BeanFactory 添加⾃⼰的 BeanPostProcessor（Bean的后置处理器）</p><p> <strong>invokeBeanFactoryPostProcessors()</strong></p><p>调⽤bean ⼯⼚的后置处理器</p><p> <strong>registerBeanPostProcessors()</strong></p><p>注册 bean 后置处理器</p><p>先去容器中获取所有的BeanPostProcessor的bean名称， 再 按照BeanPostProcessor实现的优先级接⼝来分离我们的后置处理器</p><p>把实现了priorityOrdered注册到容器中， 处理实现Ordered的bean后置处理器， 排序并且注册我们实现了Order接⼝的后置处理器，</p><p> 实例化我们所有的⾮排序接⼝的， 注册我们普通的没有实现任何排序接⼝的， 注册MergedBeanDefinitionPostProcessor类型的后置处理器，注册ApplicationListenerDetector应⽤监听器探测器的后置处理器</p><p><strong>initApplicationEventMulticaster()</strong></p><p>初始化事件多播器， 从bean⼯⼚中获取或者直接显示的new⼀个事件多播器赋值给applicatoinContext对象的applicationEventMulticaster属性。事件多播器采⽤典型的设计模式就是观察者模式 多播器作为的是⼀个被观察者。</p><p> <strong>onRefresh()</strong></p><p>留个⼦类实现，其中 Spring Boot 就是从这个⽅法进⾏ tomcat 的启动。</p><p><strong>registerListeners()</strong></p><p>把事件监听器注册到事件多播器上</p><p>先获取容器中所有的监听器对象， 把监听器挨个的注册到我们的事件多播器上去</p><p>获取bean定义中的监听器对象， 把监听器的名称注册到我们的事件多播器上</p><p>获取我们的早期事件，通过多播器进⾏播发早期事件</p><p>如何发布事件，通过事件多播器⽅法：multicastEvent()</p><p><strong>finishBeanFactoryInitialization()</strong></p><p>实例化所有的⾮懒加载的单实例 bean</p><p><strong>finishRefresh()</strong></p><p>最后刷新容器发布刷新事件（Spring cloud eureka 也是从这⾥启动的）</p><ol><li>初始化⽣命周期处理器：initLifecycleProcessor() ⽅法。 先获取beanFactory⼯⼚，判断容器中是否有lifecycleProcessor，有就直接从容器中拿，没有创建⼀个DefaultLifecycleProcessor，然后注册到容器中</li><li>调⽤⽣命周期处理器的 getLifecycleProcessor().onRefresh() ⽅法，其中调用的是startBeans(true) ⽅法，主要的功能是找到 Spring 容器的 Lifecycle 类型的 Bean，然后调⽤ start() 去启动。</li><li>发布 ContextRefreshedEvent 事件：主要就是调⽤事件多播器的发布事件⽅法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/29/hello-world/"/>
      <url>/2023/01/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
